# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Куканова Мария Андреевна
- ЗПИЭ-20-2

| Задание | Сам_раб |
| ------  | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы.

```python
import time


def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}: {execution_time} секунд.")
        return result

    return wrapper


@measure_time
def fibo(n):
    if n <= 1:
        return n
    else:
        return fibo(n - 1) + fibo(n - 2)


# Пример вызова функции Фибоначчи с использованием декоратора
fibo(10)
```

### Результат
![Меню](https://github.com/Ckroulis/lab/blob/Tema-10/pic/Lab10_1.jpg)

## Выводы
В данном задании я изучила декораторы, которые могут использоваться для изменения поведения функций. Особенно рассматриваем декораторы, которые позволяют измерять время выполнения функций.
  
## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
try:
    with open("Пустой файл.txt", "r") as file:
        data = file.read()
        if len(data) == 0:
            raise Exception("файл пустой")
        else:
            print(data)
except FileNotFoundError:
    print("Файл не найден")
except Exception as e:
    print(str(e))

try:
    with open("Не пустой файл.txt", "r") as file:
        data = file.read()
        if len(data) == 0:
            raise Exception("файл пустой")
        else:
            print(data)
except FileNotFoundError:
    print("Файл не найден")
except Exception as e:
    print(str(e))
```

### Результат
![Меню](https://github.com/Ckroulis/lab/blob/Tema-10/pic/Lab10_2.jpg)

## Выводы
Ознакомились с конструкцией try/except, которая служит для обработки исключений. Внутрь блока try помещается код, в котором могут возникнуть ошибки, а блок except содержит код, который будет выполнен в случае возникновения исключения. Таким образом, мы можем предотвратить аварийное завершение программы.
  
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль.

```python
def sum_with_input(num1):
    try:
        num2 = float(input("Введите число: "))  # Ввод числа, преобразованного в тип float
        result = num1 + num2
        print("Результат:", result)
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")


sum_with_input(2)
```

### Результат
![Меню](https://github.com/Ckroulis/lab/blob/Tema-10/pic/Lab10_3.1.jpg)
![Меню](https://github.com/Ckroulis/lab/blob/Tema-10/pic/Lab10_3.2.jpg)

## Выводы
В данном задании мы используем блок try/except для обработки ошибки, которая может возникнуть при попытке преобразовать ввод пользователя в число. Если ввод не может быть преобразован в число, то вызывается исключение ValueError, которое перехватывается в блоке except и возвращается сообщением об ошибке.

## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
import time

# Создаем класс декоратора CatDecorator
class CatDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start_time = time.time()

        result = self.func(*args, **kwargs)

        execution_time = time.time() - start_time

        print(f"Функция '{self.func.__name__}' выполнилась за {execution_time} секунд.")

        return result

# Функция, которая выводит приветствие с именем кошки
@CatDecorator
def greet_cat(name):
    print(f"Привет, {name}! Мур-мур-мур!")

# Функция, которая складывает два числа с небольшой задержкой
@CatDecorator
def add_with_delay(a, b):
    time.sleep(2)
    return a + b


greet_cat("Кисыч")
result = add_with_delay(3, 5)
print(f"Результат сложения: {result}")
```

### Результат
![Меню](https://github.com/Ckroulis/lab/blob/Tema-10/pic/Lab10_4.jpg)

## Выводы
В данном задании мы изучили процесс создания и использования собственных декораторов. Для этого мы создали декоратор под названием "my_decorator", который помогает вести логирование результатов вызова функций. Затем мы определили две функции, которые мы хотим отслеживать и занесли их в лог. Мы сможем вызвать эти функции, указав имя пользователя вручную.

## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
### 

```python
class TailNotFoundException(Exception):
    pass
def find_cat_tail(cat):
    if 'хвост' not in cat:
        raise TailNotFoundException("У кошки нет хвоста")
    else:
        return cat['хвост']

cat1 = {'Имя': 'Кискисыч', 'Цвет': 'Серый'}
try:
    tail = find_cat_tail(cat1)
    print(f"{cat1['Имя']} длина хвоста: {tail}")
except TailNotFoundException as e:
    print(e)
def measure_tail_length(cat):
    try:
        tail = find_cat_tail(cat)
        length = len(tail)
        print(f"{cat['Имя']} длина хвоста: {length} cm")
    except TailNotFoundException as e:
        print(e)

cat2 = {'Имя': 'Пушистик', 'Цвет': 'Ораньжевый'}
measure_tail_length(cat1)
```

### Результат
![Меню](https://github.com/Ckroulis/lab/blob/Tema-10/pic/Lab10_5.jpg)

## Выводы
Создала собственное исключение, которое будет использоваться в двух любых фрагментах кода. 

## Общие выводы по теме
Мы изучили декораторы, которые позволяют изменять поведение функций, методов или классов без изменения самих объектов. Декораторы предоставляют возможность расширить или модифицировать функциональность вызываемых объектов. Также мы изучили исключения, которые позволяют управлять поведением программы в случае возникновения ошибок. Исключения позволяют обрабатывать ошибки и предоставляют удобный способ управления потоком выполнения программы при возникновении непредвиденных ситуаций. Кроме того, мы научились создавать собственные декораторы и исключения, что дает возможность индивидуально адаптировать их к нуждам конкретного проекта или задачи.
